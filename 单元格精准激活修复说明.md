# ListView 单元格精准激活修复说明

## 问题描述
点击剪贴板管理窗口中的表格单元格时，会激活表格中那一整行单元格，而不能精准激活用户点击的那个单个单元格。

## 修复方案

### 1. 使用 `LVM_SUBITEMHITTEST` API 精确获取列索引
**问题根源**：
- 原代码依赖 `NM_CLICK` 消息的 `NMITEMACTIVATE` 结构中的 `iSubItem` 字段
- 该字段在某些情况下不可靠，可能总是返回 0（第一列）
- 结构体偏移量计算在 64 位系统上可能有对齐问题

**解决方法**：
- 使用 `LVM_SUBITEMHITTEST` API（消息代码 `0x1039`）
- 根据鼠标点击位置精确获取行索引（`iItem`）和列索引（`iSubItem`）
- 这个 API 比直接从通知结构中读取更可靠

### 2. 禁用 ListView 的默认行选中行为
**问题根源**：
- ListView 的默认行为是选中整行，即使没有 `LVS_EX_FULLROWSELECT` 样式
- `ItemSelect` 事件会被触发，导致整行被选中
- 即使事后取消选中，用户也会看到闪烁

**解决方法**：
- 在 ListView 创建后，移除 `LVS_SHOWSELALWAYS` 样式
- 移除 `LVS_EX_FULLROWSELECT` 扩展样式
- 在 `OnClipboardListViewItemSelect` 事件处理函数的**最开始**立即调用 `UnselectAllListViewRows()`
- 这样可以在选中发生的瞬间立即取消，最小化闪烁

### 3. 修复双击事件处理
**问题根源**：
- 原代码使用延迟处理 + 列宽计算来确定列索引
- 如果用户在延迟期间移动鼠标，会导致列索引错误
- 列宽计算不准确（可能因为用户调整了列宽）

**解决方法**：
- 删除延迟处理逻辑（`SetTimer`）
- 改用相同的 `LVM_SUBITEMHITTEST` API 立即获取精确的列索引
- 避免了鼠标移动导致的错误

## 修改的文件
- `CursorHelper (1).ahk`

## 修改的函数
1. **`OnClipboardListViewWMNotify`** (行 13811-13917)
   - 使用 `LVM_SUBITEMHITTEST` 精确获取单元格位置
   - 立即更新高亮状态和覆盖层

2. **`OnClipboardListViewDoubleClick`** (行 13753-13809)
   - 使用 `LVM_SUBITEMHITTEST` 精确获取列索引
   - 删除了旧的延迟处理和列宽计算逻辑

3. **`OnClipboardListViewItemSelect`** (行 14130-14177)
   - 在函数开始立即调用 `UnselectAllListViewRows()`
   - 防止整行被选中

4. **ListView 创建代码** (行 12489-12518)
   - 添加了禁用默认选中行为的样式设置
   - 移除 `LVS_SHOWSELALWAYS` 和 `LVS_EX_FULLROWSELECT` 样式

## 测试步骤

### 1. 重新加载脚本
```
右键任务栏托盘图标 -> Reload Script
或者直接运行修改后的 CursorHelper (1).ahk
```

### 2. 打开剪贴板管理窗口
- 使用快捷键打开剪贴板管理窗口
- 切换到 "CapsLockC" 标签页（显示 ListView 表格）

### 3. 测试单击单元格
**预期行为**：
- ✅ 点击任意单元格，只有该单元格被高亮（显示蓝色覆盖层）
- ✅ 不会出现整行被选中的蓝色背景
- ✅ 统计信息正确显示（例如："阶段 1：共 5 项"）
- ✅ 可以点击第一列（阶段标签列）
- ✅ 可以点击第二列及后续列（第1次、第2次等内容列）

**测试用例**：
- 点击第一列（阶段标签列）的单元格 → 应该高亮该单元格
- 点击第二列（第1次复制列）的单元格 → 应该高亮该单元格
- 点击第三列（第2次复制列）的单元格 → 应该高亮该单元格
- 快速连续点击不同的单元格 → 高亮应该跟随点击位置移动
- 观察是否有整行选中的闪烁 → 不应该有整行选中

### 4. 测试双击单元格
**预期行为**：
- ✅ 双击任意单元格，弹出浮窗显示该单元格的完整内容
- ✅ 浮窗标题显示正确的行列位置（例如："单元格内容 (行2, 列3)"）
- ✅ 不会弹出错误的单元格内容

**测试用例**：
- 双击第一列的单元格
- 双击第二列及后续列的单元格
- 快速双击不同的单元格

### 5. 边界测试
**测试用例**：
- 点击 ListView 的空白区域（没有数据的行）
- 点击 ListView 的表头（列标题）
- 在有很多列的情况下测试（确保列索引计算正确）
- 调整列宽后再测试（确保不依赖列宽计算）

## 技术细节

### `LVM_SUBITEMHITTEST` API
```ahk
; 准备 LVHITTESTINFO 结构
LVHITTESTINFO := Buffer(24, 0)
NumPut("Int", ClientX, LVHITTESTINFO, 0)   ; pt.x
NumPut("Int", ClientY, LVHITTESTINFO, 4)   ; pt.y

; 调用 API
Result := DllCall("SendMessage", "Ptr", LV_Hwnd, "UInt", 0x1039, "Ptr", 0, "Ptr", LVHITTESTINFO.Ptr, "Int")

; 读取结果
RowIndex := NumGet(LVHITTESTINFO, 12, "Int") + 1  ; iItem
ColIndex := NumGet(LVHITTESTINFO, 16, "Int") + 1  ; iSubItem
```

### 禁用选中样式
```ahk
; 移除 LVS_SHOWSELALWAYS (0x0008)
CurrentStyle := DllCall("GetWindowLongPtr", "Ptr", LV_Hwnd, "Int", -16, "Ptr")
NewStyle := CurrentStyle & ~0x0008
DllCall("SetWindowLongPtr", "Ptr", LV_Hwnd, "Int", -16, "Ptr", NewStyle)

; 移除 LVS_EX_FULLROWSELECT (0x00000020)
CurrentExStyle := DllCall("SendMessage", "Ptr", LV_Hwnd, "UInt", 0x1037, "Ptr", 0, "Ptr", 0, "UInt")
NewExStyle := CurrentExStyle & ~0x00000020
DllCall("SendMessage", "Ptr", LV_Hwnd, "UInt", 0x1036, "Ptr", 0, "Ptr", NewExStyle, "UInt")
```

## 已知限制
1. **覆盖层可能会遮挡文本**：如果覆盖层颜色太深，可能会影响文本可读性
   - 解决方法：在 `UpdateClipboardHighlightOverlay` 中调整 `HighlightColor` 的透明度

2. **窗口移动时覆盖层可能不同步**：如果用户快速移动窗口，覆盖层可能会短暂错位
   - 解决方法：监听窗口移动事件，实时更新覆盖层位置

## 如果问题仍然存在

### 调试步骤
1. **检查调试日志**：
   - 打开 `clipboard_debug.log` 文件（位于脚本目录）
   - 查看点击时的日志输出，格式如下：
     ```
     [2025-12-28 10:30:45] Click: ClientX=120, ClientY=45, Result=0, flags=0x1, iItem=2, iSubItem=1
     ```
   - 检查 `iSubItem` 的值：
     - 如果总是 0，说明 `LVM_SUBITEMHITTEST` 没有正确返回列索引
     - 如果是正确的值（0, 1, 2...），说明 API 工作正常

2. **验证列索引**：
   - 点击第一列，查看日志中 `iSubItem` 是否为 0
   - 点击第二列，查看日志中 `iSubItem` 是否为 1
   - 点击第三列，查看日志中 `iSubItem` 是否为 2

3. **检查覆盖层位置**：
   - 如果覆盖层显示在错误的位置，可能是坐标计算问题
   - 如果覆盖层根本不显示，可能是高亮状态没有更新

### 可能的原因和解决方法

#### 问题1：`iSubItem` 总是返回 0
**原因**：`LVM_SUBITEMHITTEST` 在某些 ListView 配置下不返回列索引

**解决方法**：
- 方法A：添加 `LVS_EX_SUBITEMIMAGES` 扩展样式
  ```ahk
  NewExStyle := CurrentExStyle | 0x00000002  ; 添加 LVS_EX_SUBITEMIMAGES
  ```
- 方法B：使用列宽计算方法（备用方案）
  ```ahk
  ; 遍历所有列，计算点击位置对应的列索引
  ColIndex := 1
  AccumWidth := 0
  Loop ColCount {
      ColWidth := SendMessage(0x101D, A_Index - 1, 0, LV_Hwnd)  ; LVM_GETCOLUMNWIDTH
      if (ClientX >= AccumWidth && ClientX < AccumWidth + ColWidth) {
          ColIndex := A_Index
          break
      }
      AccumWidth += ColWidth
  }
  ```

#### 问题2：整行仍然被选中
**原因**：`UnselectAllListViewRows()` 执行时机太晚或没有生效

**解决方法**：
- 在 `OnClipboardListViewItemSelect` 函数开始立即调用（已实现）
- 或者完全禁用 `ItemSelect` 事件：
  ```ahk
  ; 注释掉这一行
  ; ListViewCtrl.OnEvent("ItemSelect", OnClipboardListViewItemSelect)
  ```

#### 问题3：DPI 缩放导致坐标错误
**原因**：高 DPI 设置可能影响坐标计算

**解决方法**：
- 使用 DPI 感知 API：
  ```ahk
  DllCall("SetProcessDPIAware")  ; 在脚本开始处调用
  ```

### 系统兼容性
- **Windows 10/11**：完全支持
- **Windows 7/8**：可能需要调整（部分 API 行为不同）
- **32 位系统**：结构体偏移量可能需要调整

## 总结
此次修复解决了 ListView 单元格点击时整行被激活的问题，通过以下三个关键改进：
1. 使用 `LVM_SUBITEMHITTEST` API 精确获取列索引
2. 禁用 ListView 的默认行选中行为
3. 在 `ItemSelect` 事件中立即取消选中

现在点击表格中的任意单元格，应该只会高亮该单元格，而不会激活整行。
