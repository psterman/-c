# 单元格高亮调试步骤

## 最新修复

### 问题1：Width=0 导致覆盖层被销毁
**原因**：`LVM_GETSUBITEMRECT` 对于子项（列索引 > 0）必须使用 `LVIR_BOUNDS (0)`，而不是 `LVIR_LABEL (2)`

**修复**：
```ahk
if (ClipboardListViewHighlightedCol > 1) {
    NumPut("Int", 0, RECT, 4)  ; LVIR_BOUNDS (0) - 用于子项
} else {
    NumPut("Int", 2, RECT, 4)  ; LVIR_LABEL (2) - 用于第一列
}
```

### 问题2：覆盖层位置为负数（X=-374）
**原因**：窗口坐标计算可能有问题，需要查看调试日志确认

**调试信息**：现在会记录窗口和ListView的位置

## 测试步骤

1. **重新加载脚本**
2. **删除旧的调试日志**：
   ```
   删除 clipboard_debug.log 文件
   ```
3. **打开剪贴板管理窗口**
4. **点击第一行第二列单元格**
5. **查看调试日志**，应该看到：
   ```
   [时间] Click: ClientX=..., ClientY=..., Result=0, flags=0x4, iItem=0, iSubItem=1
   [时间] Window: X=..., Y=..., ListView: X=..., Y=..., ScreenX=..., ScreenY=...
   [时间] GetSubItemRect: Row=1, Col=2, Result=1
   [时间] CellRect: Left=..., Top=..., Right=..., Bottom=..., Width=..., Height=...
   [时间] Overlay shown at: X=..., Y=..., W=..., H=...
   ```

## 预期结果

### 成功的日志示例
```
[时间] Click: ClientX=142, ClientY=29, Result=0, flags=0x4, iItem=0, iSubItem=1
[时间] Window: X=100, Y=100, ListView: X=20, Y=90, ScreenX=120, ScreenY=190
[时间] GetSubItemRect: Row=1, Col=2, Result=1
[时间] CellRect: Left=100, Top=24, Right=250, Bottom=42, Width=150, Height=18
[时间] Overlay shown at: X=220, Y=214, W=150, H=18
```

### 失败的情况

#### 情况1：Width=0
```
[时间] CellRect: Left=408, Top=24, Right=408, Bottom=42, Width=0, Height=18
[时间] Invalid cell size: Width=0, Height=18
```
**说明**：`LVM_GETSUBITEMRECT` 没有正确返回子项矩形
**解决**：已修复，使用 `LVIR_BOUNDS (0)` 代替 `LVIR_LABEL (2)`

#### 情况2：负数坐标
```
[时间] Overlay shown at: X=-374, Y=827, W=308, H=18
```
**说明**：窗口坐标计算错误
**可能原因**：
- 窗口位置获取错误
- ListView 位置获取错误
- 坐标系统混淆（客户端坐标 vs 屏幕坐标）

## 如果仍然失败

请提供完整的调试日志（最后 10-15 行），包括：
1. Click 行
2. Window 行（新增）
3. GetSubItemRect 行
4. CellRect 行
5. Overlay shown 行（如果有）
6. 任何错误信息

根据这些信息，我可以进一步诊断问题。

## 可能的备用方案

如果 `LVM_GETSUBITEMRECT` 仍然不工作，可以使用以下备用方案：

### 方案A：使用列宽计算
```ahk
; 计算单元格位置
CellLeft := 0
Loop (ClipboardListViewHighlightedCol - 1) {
    ColWidth := SendMessage(0x101D, A_Index - 1, 0, LV_Hwnd)  ; LVM_GETCOLUMNWIDTH
    CellLeft += ColWidth
}
CellWidth := SendMessage(0x101D, ClipboardListViewHighlightedCol - 1, 0, LV_Hwnd)

; 计算行高
CellTop := (ClipboardListViewHighlightedRow - 1) * RowHeight
CellHeight := RowHeight
```

### 方案B：使用 LVM_GETITEMRECT 获取整行，然后计算列位置
```ahk
; 获取整行矩形
RECT := Buffer(16, 0)
NumPut("Int", 0, RECT, 0)  ; LVIR_BOUNDS
DllCall("SendMessage", "Ptr", LV_Hwnd, "UInt", 0x100E, "Ptr", RowIndex - 1, "Ptr", RECT.Ptr)

; 然后使用列宽计算列位置
```

## 注意事项

1. **确保 ListView 有数据**：如果 ListView 是空的，API 可能返回错误
2. **确保窗口可见**：如果窗口最小化或隐藏，坐标可能不正确
3. **DPI 缩放**：高 DPI 设置可能影响坐标计算
